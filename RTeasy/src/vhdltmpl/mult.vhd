-- VHDL model of UNNAMED
-- generated by RTeasy

PACKAGE rteasy_functions IS
  FUNCTION bool_signed_lt (a, b : std_logic_vector; sign_index : natural)
    RETURN boolean;
  FUNCTION signed_lt (a, b : std_logic_vector; sign_index : natural)
    RETURN std_logic_vector;
  FUNCTION signed_le (a, b : std_logic_vector; sign_index : natural)
    RETURN std_logic_vector;
  FUNCTION signed_gt (a, b : std_logic_vector; sign_index : natural)
    RETURN std_logic_vector;
  FUNCTION signed_ge (a, b : std_logic_vector; sign_index : natural)
    RETURN std_logic_vector;
  FUNCTION signed_eq (a, b : std_logic_vector) RETURN std_logic_vector;
  FUNCTION signed_ne (a, b : std_logic_vector) RETURN std_logic_vector;
END rteasy_functions;

PACKAGE BODY rteasy_functions IS

  -- signed relative comparison functions
  FUNCTION bool_signed_lt (a, b : std_logic_vector; sign_index : natural)
    RETURN boolean IS
  BEGIN
    IF a(sign_index) = b(sign_index) THEN
      RETURN a < b; 
    ELSE
      RETURN a(sign_index) = '1';
    END IF;
  END bool_signed_lt;

  FUNCTION signed_lt (a, b : std_logic_vector; sign_index : natural)
    RETURN std_logic_vector IS
  BEGIN
    IF bool_signed_lt(a,b,sign_index) THEN RETURN "1";
    ELSE RETURN "0";
    END IF;
  END signed_lt;

  FUNCTION signed_le (a, b : std_logic_vector; sign_index : natural)
    RETURN std_logic_vector IS
  BEGIN
    IF (a = b) OR bool_signed_lt(a,b,sign_index) THEN RETURN "1";
    ELSE RETURN "0";
    END IF;
  END signed_le;

  FUNCTION signed_gt (a, b : std_logic_vector; sign_index : natural)
    RETURN std_logic_vector IS
  BEGIN
    IF (a = b) OR bool_signed_lt(a,b,sign_index) THEN RETURN "0";
    ELSE RETURN "1";
    END IF;
  END signed_gt;

  FUNCTION signed_ge (a, b : std_logic_vector; sign_index : natural)
    RETURN std_logic_vector IS
  BEGIN
    IF bool_signed_lt(a,b,sign_index) THEN RETURN "0";
    ELSE RETURN "1";
    END IF;
  END signed_ge;

  FUNCTION signed_eq (a, b : std_logic_vector) RETURN std_logic_vector IS
  BEGIN
    IF a = b THEN RETURN "1";
    ELSE RETURN "0";
    END IF;
  END signed_eq;

  FUNCTION signed_ne (a, b : std_logic_vector) RETURN std_logic_vector IS
  BEGIN
    IF a = b THEN RETURN "0";
    ELSE RETURN "1";
    END IF;
  END signed_ne;

END rteasy_functions;

-- generic components

-- D-Flip-Flop register component
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY dff_reg IS
  GENERIC(width : positive; triggering_edge : bit);
  PORT(
    CLK, RESET : IN  std_logic;
    INPUT      : IN  std_logic_vector(width-1 DOWNTO 0);
    OUTPUT     : OUT std_logic_vector(width-1 DOWNTO 0)
  );
END dff_reg;

ARCHITECTURE behavioural OF dff_reg IS
BEGIN
  gen_rising_edge: IF triggering_edge='1' GENERATE
    reg_proc_rising: PROCESS(CLK,RESET)
    BEGIN
      IF RESET='1' THEN OUTPUT <= (OTHERS => '0');
      ELSIF rising_edge(CLK) THEN OUTPUT <= INPUT; END IF;
    END PROCESS;
  END GENERATE;

  gen_falling_edge: IF triggering_edge='0' GENERATE
    reg_proc_falling: PROCESS(CLK,RESET)
    BEGIN
      IF RESET='1' THEN OUTPUT <= (OTHERS => '0');
      ELSIF falling_edge(CLK) THEN OUTPUT <= INPUT; END IF;
    END PROCESS;
  END GENERATE;
END behavioural;

-- Tri-State driver component
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY tristate IS
  GENERIC(width : positive);
  PORT(
    ENABLE : IN  std_logic;
    INPUT  : IN  std_logic_vector(width-1 DOWNTO 0);
    OUTPUT : OUT std_logic_vector(width-1 DOWNTO 0)
  );
END tristate;

ARCHITECTURE primitive OF tristate IS
BEGIN
  OUTPUT <= INPUT WHEN ENABLE='1' ELSE (OTHERS => 'Z');
END primitive;

-- CONTROL UNIT

-- combinatorial circuit for state transition function
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY UNNAMED_cu_statetrans_net IS
  PORT(
    I         : IN  std_logic_vector(0 TO 0);
    STATE     : IN  std_logic_vector(1 DOWNTO 0);
    NEXTSTATE : OUT std_logic_vector(1 DOWNTO 0)
  );
  CONSTANT endstate : std_logic_vector(1 DOWNTO 0) := "11";
END UNNAMED_cu_statetrans_net;

ARCHITECTURE behavioural OF UNNAMED_cu_statetrans_net IS
BEGIN
  statetrans: PROCESS(I,STATE)
  BEGIN
    CASE STATE IS
      WHEN "00" =>        -- BEGIN:
        NEXTSTATE <= "01";
      WHEN "01" =>
        NEXTSTATE <= "10";
      WHEN "10" =>        -- LOOP:
        IF I(0)='1' THEN -- if FAKTOR <> 0 then goto LOOP fi
          NEXTSTATE <= "10";
        ELSE
          NEXTSTATE <= endstate;
        END IF;
      WHEN OTHERS =>
        NEXTSTATE <= endstate;
    END CASE;
  END PROCESS;
END behavioural;

-- combinatorial circuit for output function
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY UNNAMED_cu_output_net IS
  PORT(
    I     : IN  std_logic_vector(0 TO 0);
    STATE : IN  std_logic_vector(1 DOWNTO 0);
    C     : OUT std_logic_vector(0 TO 5)
  );
END UNNAMED_cu_output_net;

ARCHITECTURE behavioural OF UNNAMED_cu_output_net IS
BEGIN
  output: PROCESS(I,STATE)
  BEGIN
    CASE STATE IS
      WHEN "00" =>        -- BEGIN:
        C(0) <= '1';
        C(1) <= '1';
        C(2) <= '0';
        C(3) <= '0';
        C(4) <= '0';
        C(5) <= '0';
      WHEN "01" =>
        C(0) <= '0';
        C(1) <= '0';
        C(2) <= '1';
        C(3) <= '0';
        C(4) <= '0';
        C(5) <= '0';
      WHEN "10" =>        -- LOOP:
        C(0) <= '0';
        C(1) <= '0';
        C(2) <= '0';
        -- if FAKTOR <> 0 then ERG <- ERG + A fi
        C(3) <= I(0);
        -- if FAKTOR <> 0 then FAKTOR <- FAKTOR - 1 fi
        C(4) <= I(0);
        -- if not FAKTOR <> 0 then OUTBUS <- ERG fi
        C(5) <= NOT (I(0));
      WHEN OTHERS =>
        C <= (OTHERS => '0');
    END CASE;
  END PROCESS;
END behavioural;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY UNNAMED_cu IS
  PORT(
    CLK, RESET : IN  std_logic;
    C          : OUT std_logic_vector(0 TO 5);
    I          : IN  std_logic_vector(0 TO 0)
  );
END UNNAMED_cu;

ARCHITECTURE struct OF UNNAMED_cu IS
  SIGNAL I_BUFFERED : std_logic_vector(0 TO 0);
  SIGNAL C_SIG : std_logic_vector(0 TO 5);
  SIGNAL STATE, NEXTSTATE : std_logic_vector(1 DOWNTO 0);

  COMPONENT dff_reg
    GENERIC(width : positive; triggering_edge : bit);
    PORT(
      CLK, RESET : IN  std_logic;
      INPUT      : IN  std_logic_vector(width-1 DOWNTO 0);
      OUTPUT     : OUT std_logic_vector(width-1 DOWNTO 0)
    );
  END COMPONENT;
  
  FOR ALL : dff_reg USE ENTITY WORK.dff_reg(behavioural);

  COMPONENT UNNAMED_cu_statetrans_net
    PORT(
      I         : IN  std_logic_vector(0 TO 0);
      STATE     : IN  std_logic_vector(1 DOWNTO 0);
      NEXTSTATE : OUT std_logic_vector(1 DOWNTO 0)
    );
  END COMPONENT;
  
  FOR ALL : UNNAMED_cu_statetrans_net USE ENTITY
    WORK.UNNAMED_cu_statetrans_net(behavioural);

  COMPONENT UNNAMED_cu_output_net
    PORT(
      I     : IN  std_logic_vector(0 TO 0);
      STATE : IN  std_logic_vector(1 DOWNTO 0);
      C     : OUT std_logic_vector(0 TO 5)
    );
  END COMPONENT;
  
  FOR ALL : UNNAMED_cu_output_net USE ENTITY
    WORK.UNNAMED_cu_output_net(behavioural);
BEGIN
  -- instantiate condition buffer register
  condbuf_register: dff_reg
    GENERIC MAP(width => 1, triggering_edge => '1')
    PORT MAP(CLK => CLK, RESET => RESET, INPUT => I, OUTPUT => I_BUFFERED);
  
  -- instantiate state register
  state_register: dff_reg
    GENERIC MAP(width => 2, triggering_edge => '1')
    PORT MAP(CLK => CLK, RESET => RESET, INPUT => NEXTSTATE, OUTPUT => STATE);
  
  -- instantiate circuit for state transition function
  statetrans: UNNAMED_cu_statetrans_net
    PORT MAP(I => I_BUFFERED, STATE => STATE, NEXTSTATE => NEXTSTATE);
  
  -- instantiate circuit for output function driving control signals
  output: UNNAMED_cu_output_net
    PORT MAP(I => I_BUFFERED, STATE => STATE, C => C_SIG);
  
  -- only drive control signals when CLK='0' to avoid driving hazards to
  -- operation unit
  C <= C_SIG WHEN CLK='0' ELSE (OTHERS => '0');
END struct;

-- OPERATION UNIT

-- circuits realizing register-transfer operations

-- realization of RT operation A <- INBUS
-- triggered by control signal C(0)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE work.rteasy_functions.ALL;

ENTITY UNNAMED_rtop_C0_circuit IS
  PORT(
    bus_INBUS_0_7 : IN std_logic_vector(0 TO 7);
    OUTPUT : OUT std_logic_vector(7 DOWNTO 0)
  );
END UNNAMED_rtop_C0_circuit;

ARCHITECTURE primitive OF UNNAMED_rtop_C0_circuit IS
BEGIN
  -- INBUS
  OUTPUT <= bus_INBUS_0_7(0 TO 7);
END primitive;

-- realization of RT operation ERG <- 0
-- triggered by control signal C(1)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE work.rteasy_functions.ALL;

ENTITY UNNAMED_rtop_C1_circuit IS
  PORT(
    OUTPUT : OUT std_logic_vector(7 DOWNTO 0)
  );
END UNNAMED_rtop_C1_circuit;

ARCHITECTURE primitive OF UNNAMED_rtop_C1_circuit IS
BEGIN
  -- 0
  OUTPUT <= "00000000";
END primitive;

-- realization of RT operation FAKTOR <- INBUS
-- triggered by control signal C(2)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE work.rteasy_functions.ALL;

ENTITY UNNAMED_rtop_C2_circuit IS
  PORT(
    bus_INBUS_0_7 : IN std_logic_vector(0 TO 7);
    OUTPUT : OUT std_logic_vector(7 DOWNTO 0)
  );
END UNNAMED_rtop_C2_circuit;

ARCHITECTURE primitive OF UNNAMED_rtop_C2_circuit IS
BEGIN
  -- INBUS
  OUTPUT <= bus_INBUS_0_7(0 TO 7);
END primitive;

-- realization of RT operation ERG <- ERG + A
-- triggered by control signal C(3)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE work.rteasy_functions.ALL;

ENTITY UNNAMED_rtop_C3_circuit IS
  PORT(
    reg_ERG_out_0_7 : IN std_logic_vector(0 TO 7);
    reg_A_out_0_7 : IN std_logic_vector(0 TO 7);
    OUTPUT : OUT std_logic_vector(8 DOWNTO 0)
  );
END UNNAMED_rtop_C3_circuit;

ARCHITECTURE primitive OF UNNAMED_rtop_C3_circuit IS
BEGIN
  -- ERG + A
  OUTPUT <= ("0" & reg_ERG_out_0_7(0 TO 7)) + ("0" & reg_A_out_0_7(0 TO 7));
END primitive;

-- realization of RT operation FAKTOR <- FAKTOR - 1
-- triggered by control signal C(4)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE work.rteasy_functions.ALL;

ENTITY UNNAMED_rtop_C4_circuit IS
  PORT(
    reg_FAKTOR_out_0_7 : IN std_logic_vector(0 TO 7);
    OUTPUT : OUT std_logic_vector(8 DOWNTO 0)
  );
END UNNAMED_rtop_C4_circuit;

ARCHITECTURE primitive OF UNNAMED_rtop_C4_circuit IS
BEGIN
  -- FAKTOR - 1
  OUTPUT <= ("0" & reg_FAKTOR_out_0_7(0 TO 7)) + ((not ("000000001")) + "000000001");
END primitive;

-- realization of RT operation OUTBUS <- ERG
-- triggered by control signal C(5)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE work.rteasy_functions.ALL;

ENTITY UNNAMED_rtop_C5_circuit IS
  PORT(
    reg_ERG_out_0_7 : IN std_logic_vector(0 TO 7);
    OUTPUT : OUT std_logic_vector(7 DOWNTO 0)
  );
END UNNAMED_rtop_C5_circuit;

ARCHITECTURE primitive OF UNNAMED_rtop_C5_circuit IS
BEGIN
  -- ERG
  OUTPUT <= reg_ERG_out_0_7(0 TO 7);
END primitive;

-- circuits realizing conditions

-- realization of condition FAKTOR <> 0
-- driving condition signal I(0)
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
USE work.rteasy_functions.ALL;

ENTITY UNNAMED_cond_I0_circuit IS
  PORT(
    reg_FAKTOR_out_0_7 : IN std_logic_vector(0 TO 7);
    OUTPUT : OUT std_logic_vector(0 DOWNTO 0)
  );
END UNNAMED_cond_I0_circuit;

ARCHITECTURE primitive OF UNNAMED_cond_I0_circuit IS
BEGIN
  -- FAKTOR <> 0
  OUTPUT <= signed_ne(("0" & reg_FAKTOR_out_0_7(0 TO 7)), ("000000000"), 8);
END primitive;

-- register logic circuits

-- register logic for A

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY reg_A_logic_circuit IS
  PORT(
    C0 : IN  std_logic;
    rtop_C0_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
    FROM_reg : IN  std_logic_vector (0 TO 7);
    TO_reg : OUT std_logic_vector (0 TO 7)
  );
END reg_A_logic_circuit;

ARCHITECTURE primitive OF reg_A_logic_circuit IS
BEGIN
  TO_reg(0) <= rtop_C0_out_7_0(7) WHEN C0 = '1'
  ELSE FROM_reg(0);

  TO_reg(1) <= rtop_C0_out_7_0(6) WHEN C0 = '1'
  ELSE FROM_reg(1);

  TO_reg(2) <= rtop_C0_out_7_0(5) WHEN C0 = '1'
  ELSE FROM_reg(2);

  TO_reg(3) <= rtop_C0_out_7_0(4) WHEN C0 = '1'
  ELSE FROM_reg(3);

  TO_reg(4) <= rtop_C0_out_7_0(3) WHEN C0 = '1'
  ELSE FROM_reg(4);

  TO_reg(5) <= rtop_C0_out_7_0(2) WHEN C0 = '1'
  ELSE FROM_reg(5);

  TO_reg(6) <= rtop_C0_out_7_0(1) WHEN C0 = '1'
  ELSE FROM_reg(6);

  TO_reg(7) <= rtop_C0_out_7_0(0) WHEN C0 = '1'
  ELSE FROM_reg(7);

END primitive;
-- register logic for ERG

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY reg_ERG_logic_circuit IS
  PORT(
    C1, C3 : IN  std_logic;
    rtop_C1_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
    rtop_C3_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
    FROM_reg : IN  std_logic_vector (0 TO 7);
    TO_reg : OUT std_logic_vector (0 TO 7)
  );
END reg_ERG_logic_circuit;

ARCHITECTURE primitive OF reg_ERG_logic_circuit IS
BEGIN
  TO_reg(0) <= rtop_C1_out_7_0(7) WHEN C1 = '1'
  ELSE rtop_C3_out_7_0(7) WHEN C3 = '1'
  ELSE FROM_reg(0);

  TO_reg(1) <= rtop_C1_out_7_0(6) WHEN C1 = '1'
  ELSE rtop_C3_out_7_0(6) WHEN C3 = '1'
  ELSE FROM_reg(1);

  TO_reg(2) <= rtop_C1_out_7_0(5) WHEN C1 = '1'
  ELSE rtop_C3_out_7_0(5) WHEN C3 = '1'
  ELSE FROM_reg(2);

  TO_reg(3) <= rtop_C1_out_7_0(4) WHEN C1 = '1'
  ELSE rtop_C3_out_7_0(4) WHEN C3 = '1'
  ELSE FROM_reg(3);

  TO_reg(4) <= rtop_C1_out_7_0(3) WHEN C1 = '1'
  ELSE rtop_C3_out_7_0(3) WHEN C3 = '1'
  ELSE FROM_reg(4);

  TO_reg(5) <= rtop_C1_out_7_0(2) WHEN C1 = '1'
  ELSE rtop_C3_out_7_0(2) WHEN C3 = '1'
  ELSE FROM_reg(5);

  TO_reg(6) <= rtop_C1_out_7_0(1) WHEN C1 = '1'
  ELSE rtop_C3_out_7_0(1) WHEN C3 = '1'
  ELSE FROM_reg(6);

  TO_reg(7) <= rtop_C1_out_7_0(0) WHEN C1 = '1'
  ELSE rtop_C3_out_7_0(0) WHEN C3 = '1'
  ELSE FROM_reg(7);

END primitive;
-- register logic for FAKTOR

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY reg_FAKTOR_logic_circuit IS
  PORT(
    C2, C4 : IN  std_logic;
    rtop_C2_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
    rtop_C4_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
    FROM_reg : IN  std_logic_vector (0 TO 7);
    TO_reg : OUT std_logic_vector (0 TO 7)
  );
END reg_FAKTOR_logic_circuit;

ARCHITECTURE primitive OF reg_FAKTOR_logic_circuit IS
BEGIN
  TO_reg(0) <= rtop_C2_out_7_0(7) WHEN C2 = '1'
  ELSE rtop_C4_out_7_0(7) WHEN C4 = '1'
  ELSE FROM_reg(0);

  TO_reg(1) <= rtop_C2_out_7_0(6) WHEN C2 = '1'
  ELSE rtop_C4_out_7_0(6) WHEN C4 = '1'
  ELSE FROM_reg(1);

  TO_reg(2) <= rtop_C2_out_7_0(5) WHEN C2 = '1'
  ELSE rtop_C4_out_7_0(5) WHEN C4 = '1'
  ELSE FROM_reg(2);

  TO_reg(3) <= rtop_C2_out_7_0(4) WHEN C2 = '1'
  ELSE rtop_C4_out_7_0(4) WHEN C4 = '1'
  ELSE FROM_reg(3);

  TO_reg(4) <= rtop_C2_out_7_0(3) WHEN C2 = '1'
  ELSE rtop_C4_out_7_0(3) WHEN C4 = '1'
  ELSE FROM_reg(4);

  TO_reg(5) <= rtop_C2_out_7_0(2) WHEN C2 = '1'
  ELSE rtop_C4_out_7_0(2) WHEN C4 = '1'
  ELSE FROM_reg(5);

  TO_reg(6) <= rtop_C2_out_7_0(1) WHEN C2 = '1'
  ELSE rtop_C4_out_7_0(1) WHEN C4 = '1'
  ELSE FROM_reg(6);

  TO_reg(7) <= rtop_C2_out_7_0(0) WHEN C2 = '1'
  ELSE rtop_C4_out_7_0(0) WHEN C4 = '1'
  ELSE FROM_reg(7);

END primitive;

-- bus zero driver logic circuits

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

-- bus zero driver logic for OUTBUS
ENTITY bus_OUTBUS_zero_driver_logic_circuit IS
  PORT(
    C5 : IN  std_logic; -- driving control signals
    TO_bus : OUT std_logic_vector (0 TO 7)
  );
END bus_OUTBUS_zero_driver_logic_circuit;

ARCHITECTURE primitive OF bus_OUTBUS_zero_driver_logic_circuit IS
BEGIN
  TO_bus(0) <= '0' WHEN NOT C5='1' ELSE 'Z';
  TO_bus(1) <= '0' WHEN NOT C5='1' ELSE 'Z';
  TO_bus(2) <= '0' WHEN NOT C5='1' ELSE 'Z';
  TO_bus(3) <= '0' WHEN NOT C5='1' ELSE 'Z';
  TO_bus(4) <= '0' WHEN NOT C5='1' ELSE 'Z';
  TO_bus(5) <= '0' WHEN NOT C5='1' ELSE 'Z';
  TO_bus(6) <= '0' WHEN NOT C5='1' ELSE 'Z';
  TO_bus(7) <= '0' WHEN NOT C5='1' ELSE 'Z';
END primitive;
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

-- bus zero driver logic for INBUS
ENTITY bus_INBUS_zero_driver_logic_circuit IS
  PORT(
    TO_bus : OUT std_logic_vector (0 TO 7)
  );
END bus_INBUS_zero_driver_logic_circuit;

ARCHITECTURE primitive OF bus_INBUS_zero_driver_logic_circuit IS
BEGIN
  TO_bus(0) <= '0';
  TO_bus(1) <= '0';
  TO_bus(2) <= '0';
  TO_bus(3) <= '0';
  TO_bus(4) <= '0';
  TO_bus(5) <= '0';
  TO_bus(6) <= '0';
  TO_bus(7) <= '0';
END primitive;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY UNNAMED_ou IS
  PORT(
    CLK, RESET : IN std_logic;
    C : IN  std_logic_vector(0 TO 5);
    I : OUT std_logic_vector(0 TO 0)
  );
END UNNAMED_ou;

ARCHITECTURE struct OF UNNAMED_ou IS
  -- signal declarations
  SIGNAL CLK_SIG, RESET_SIG : std_logic;
  SIGNAL C_SIG : std_logic_vector(0 TO 5);
  SIGNAL I0 : std_logic_vector(0 DOWNTO 0);
  SIGNAL bus_OUTBUS : std_logic_vector (0 TO 7);
  SIGNAL bus_INBUS : std_logic_vector (0 TO 7);
  SIGNAL reg_A_in : std_logic_vector (0 TO 7) := (OTHERS => 'L');
  SIGNAL reg_A_out : std_logic_vector (0 TO 7) := (OTHERS => '0');
  SIGNAL reg_ERG_in : std_logic_vector (0 TO 7) := (OTHERS => 'L');
  SIGNAL reg_ERG_out : std_logic_vector (0 TO 7) := (OTHERS => '0');
  SIGNAL reg_FAKTOR_in : std_logic_vector (0 TO 7) := (OTHERS => 'L');
  SIGNAL reg_FAKTOR_out : std_logic_vector (0 TO 7) := (OTHERS => '0');

  -- D-flipflop register component declaration
  COMPONENT dff_reg
    GENERIC(width : positive; triggering_edge : bit);
    PORT(
      CLK, RESET : IN  std_logic;
      INPUT      : IN  std_logic_vector(width-1 DOWNTO 0);
      OUTPUT     : OUT std_logic_vector(width-1 DOWNTO 0)
    );
  END COMPONENT;
  
  FOR ALL : dff_reg USE ENTITY WORK.dff_reg(behavioural);

  -- register logic component declarations

  COMPONENT reg_A_logic_circuit
    PORT(
      C0 : IN  std_logic;
      rtop_C0_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
      FROM_reg : IN  std_logic_vector (0 TO 7);
      TO_reg : OUT std_logic_vector (0 TO 7)
    );
  END COMPONENT;

  FOR ALL : reg_A_logic_circuit USE ENTITY WORK.reg_A_logic_circuit(primitive);

  COMPONENT reg_ERG_logic_circuit
    PORT(
      C1, C3 : IN  std_logic;
      rtop_C1_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
      rtop_C3_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
      FROM_reg : IN  std_logic_vector (0 TO 7);
      TO_reg : OUT std_logic_vector (0 TO 7)
    );
  END COMPONENT;

  FOR ALL : reg_ERG_logic_circuit USE ENTITY WORK.reg_ERG_logic_circuit(primitive);

  COMPONENT reg_FAKTOR_logic_circuit
    PORT(
      C2, C4 : IN  std_logic;
      rtop_C2_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
      rtop_C4_out_7_0 : IN std_logic_vector(7 DOWNTO 0);
      FROM_reg : IN  std_logic_vector (0 TO 7);
      TO_reg : OUT std_logic_vector (0 TO 7)
    );
  END COMPONENT;

  FOR ALL : reg_FAKTOR_logic_circuit USE ENTITY WORK.reg_FAKTOR_logic_circuit(primitive);


  -- bus zero driver logic component declarations

  COMPONENT bus_OUTBUS_zero_driver_logic_circuit
    PORT(
      C5 : IN  std_logic; -- driving control signals
      TO_bus : OUT std_logic_vector (0 TO 7)
    );
  END COMPONENT;

  FOR ALL : bus_OUTBUS_zero_driver_logic_circuit USE ENTITY WORK.bus_OUTBUS_zero_driver_logic_circuit(primitive);

  COMPONENT bus_INBUS_zero_driver_logic_circuit
    PORT(
      TO_bus : OUT std_logic_vector (0 TO 7)
    );
  END COMPONENT;

  FOR ALL : bus_INBUS_zero_driver_logic_circuit USE ENTITY WORK.bus_INBUS_zero_driver_logic_circuit(primitive);


  COMPONENT tristate
    GENERIC(width : positive);
    PORT(
      ENABLE : IN  std_logic;
      INPUT  : IN  std_logic_vector(width-1 DOWNTO 0);
      OUTPUT : OUT std_logic_vector(width-1 DOWNTO 0)
    );
  END COMPONENT;
  
  FOR ALL : tristate USE ENTITY WORK.tristate(primitive);

  -- function for input forcing (to 0 and 1)
  FUNCTION forceSL (b : std_logic) RETURN std_logic IS
  BEGIN
    CASE b IS
      WHEN '1'|'H' => RETURN '1';
      WHEN OTHERS => RETURN '0';
    END CASE;
  END forceSL;

  -- declarations for register-transfer circuits and signals

  -- RT operation A <- INBUS
  -- triggered by control signal C(0)
  SIGNAL rtop_C0_out : std_logic_vector(7 DOWNTO 0);
  COMPONENT UNNAMED_rtop_C0_circuit
    PORT(
      bus_INBUS_0_7 : IN std_logic_vector(0 TO 7);
      OUTPUT : OUT std_logic_vector(7 DOWNTO 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_rtop_C0_circuit USE ENTITY WORK.UNNAMED_rtop_C0_circuit(primitive);

  -- RT operation ERG <- 0
  -- triggered by control signal C(1)
  SIGNAL rtop_C1_out : std_logic_vector(7 DOWNTO 0);
  COMPONENT UNNAMED_rtop_C1_circuit
    PORT(
      OUTPUT : OUT std_logic_vector(7 DOWNTO 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_rtop_C1_circuit USE ENTITY WORK.UNNAMED_rtop_C1_circuit(primitive);

  -- RT operation FAKTOR <- INBUS
  -- triggered by control signal C(2)
  SIGNAL rtop_C2_out : std_logic_vector(7 DOWNTO 0);
  COMPONENT UNNAMED_rtop_C2_circuit
    PORT(
      bus_INBUS_0_7 : IN std_logic_vector(0 TO 7);
      OUTPUT : OUT std_logic_vector(7 DOWNTO 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_rtop_C2_circuit USE ENTITY WORK.UNNAMED_rtop_C2_circuit(primitive);

  -- RT operation ERG <- ERG + A
  -- triggered by control signal C(3)
  SIGNAL rtop_C3_out : std_logic_vector(8 DOWNTO 0);
  COMPONENT UNNAMED_rtop_C3_circuit
    PORT(
      reg_ERG_out_0_7 : IN std_logic_vector(0 TO 7);
      reg_A_out_0_7 : IN std_logic_vector(0 TO 7);
      OUTPUT : OUT std_logic_vector(8 DOWNTO 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_rtop_C3_circuit USE ENTITY WORK.UNNAMED_rtop_C3_circuit(primitive);

  -- RT operation FAKTOR <- FAKTOR - 1
  -- triggered by control signal C(4)
  SIGNAL rtop_C4_out : std_logic_vector(8 DOWNTO 0);
  COMPONENT UNNAMED_rtop_C4_circuit
    PORT(
      reg_FAKTOR_out_0_7 : IN std_logic_vector(0 TO 7);
      OUTPUT : OUT std_logic_vector(8 DOWNTO 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_rtop_C4_circuit USE ENTITY WORK.UNNAMED_rtop_C4_circuit(primitive);

  -- RT operation OUTBUS <- ERG
  -- triggered by control signal C(5)
  SIGNAL rtop_C5_out : std_logic_vector(7 DOWNTO 0);
  COMPONENT UNNAMED_rtop_C5_circuit
    PORT(
      reg_ERG_out_0_7 : IN std_logic_vector(0 TO 7);
      OUTPUT : OUT std_logic_vector(7 DOWNTO 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_rtop_C5_circuit USE ENTITY WORK.UNNAMED_rtop_C5_circuit(primitive);

  -- COMPONENT declarations for condition circuits

  -- condition FAKTOR <> 0
  -- driving condition signal I(0)
  COMPONENT UNNAMED_cond_I0_circuit
    PORT(
      reg_FAKTOR_out_0_7 : IN std_logic_vector(0 TO 7);
      OUTPUT : OUT std_logic_vector(0 DOWNTO 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_cond_I0_circuit USE ENTITY WORK.UNNAMED_cond_I0_circuit(primitive);
BEGIN

  CLK_SIG <= CLK; RESET_SIG <= RESET; C_SIG <= C;

  -- register logic instantiations
  -- register A
  -- component instantiation for register A
  reg_A: dff_reg
    GENERIC MAP(triggering_edge => '1', width => 8)
    PORT MAP(CLK => CLK_SIG, RESET => RESET_SIG,
             INPUT => reg_A_in,
             OUTPUT => reg_A_out);

  reg_A_logic: reg_A_logic_circuit
    PORT MAP(
      C0 => C_SIG(0),
      rtop_C0_out_7_0 => rtop_C0_out(7 DOWNTO 0),
      FROM_reg => reg_A_out,
      TO_reg => reg_A_in);

  -- register ERG
  -- component instantiation for register ERG
  reg_ERG: dff_reg
    GENERIC MAP(triggering_edge => '1', width => 8)
    PORT MAP(CLK => CLK_SIG, RESET => RESET_SIG,
             INPUT => reg_ERG_in,
             OUTPUT => reg_ERG_out);

  reg_ERG_logic: reg_ERG_logic_circuit
    PORT MAP(
      C1 => C_SIG(1),
      C3 => C_SIG(3),
      rtop_C1_out_7_0 => rtop_C1_out(7 DOWNTO 0),
      rtop_C3_out_7_0 => rtop_C3_out(7 DOWNTO 0),
      FROM_reg => reg_ERG_out,
      TO_reg => reg_ERG_in);

  -- register FAKTOR
  -- component instantiation for register FAKTOR
  reg_FAKTOR: dff_reg
    GENERIC MAP(triggering_edge => '1', width => 8)
    PORT MAP(CLK => CLK_SIG, RESET => RESET_SIG,
             INPUT => reg_FAKTOR_in,
             OUTPUT => reg_FAKTOR_out);

  reg_FAKTOR_logic: reg_FAKTOR_logic_circuit
    PORT MAP(
      C2 => C_SIG(2),
      C4 => C_SIG(4),
      rtop_C2_out_7_0 => rtop_C2_out(7 DOWNTO 0),
      rtop_C4_out_7_0 => rtop_C4_out(7 DOWNTO 0),
      FROM_reg => reg_FAKTOR_out,
      TO_reg => reg_FAKTOR_in);

  -- bus zero driver logic logic instantiations
  bus_OUTBUS_zero_driver_logic: bus_OUTBUS_zero_driver_logic_circuit
    PORT MAP(
      C5 => C_SIG(5),
      TO_bus => bus_OUTBUS);
  bus_INBUS_zero_driver_logic: bus_INBUS_zero_driver_logic_circuit
    PORT MAP(
      TO_bus => bus_INBUS);

  -- instantiations for register-transfer circuits

  -- RT operation A <- INBUS
  -- triggered by control signal C(0)
  rtop_C0: UNNAMED_rtop_C0_circuit
    PORT MAP(
      bus_INBUS_0_7 => bus_INBUS(0 TO 7),
      OUTPUT => rtop_C0_out);

  -- RT operation ERG <- 0
  -- triggered by control signal C(1)
  rtop_C1: UNNAMED_rtop_C1_circuit
    PORT MAP(
      OUTPUT => rtop_C1_out);

  -- RT operation FAKTOR <- INBUS
  -- triggered by control signal C(2)
  rtop_C2: UNNAMED_rtop_C2_circuit
    PORT MAP(
      bus_INBUS_0_7 => bus_INBUS(0 TO 7),
      OUTPUT => rtop_C2_out);

  -- RT operation ERG <- ERG + A
  -- triggered by control signal C(3)
  rtop_C3: UNNAMED_rtop_C3_circuit
    PORT MAP(
      reg_ERG_out_0_7 => reg_ERG_out(0 TO 7),
      reg_A_out_0_7 => reg_A_out(0 TO 7),
      OUTPUT => rtop_C3_out);

  -- RT operation FAKTOR <- FAKTOR - 1
  -- triggered by control signal C(4)
  rtop_C4: UNNAMED_rtop_C4_circuit
    PORT MAP(
      reg_FAKTOR_out_0_7 => reg_FAKTOR_out(0 TO 7),
      OUTPUT => rtop_C4_out);

  -- RT operation OUTBUS <- ERG
  -- triggered by control signal C(5)
  rtop_C5: UNNAMED_rtop_C5_circuit
    PORT MAP(
      reg_ERG_out_0_7 => reg_ERG_out(0 TO 7),
      OUTPUT => rtop_C5_out);
  tristate_OUTBUS_0_7_C5: tristate
    GENERIC MAP(width => 8)
    PORT MAP(
      ENABLE => C(5),
      INPUT => rtop_C5_out(7 DOWNTO 0),
      OUTPUT => bus_OUTBUS(0 TO 7));

  -- instantiations of condition circuits

  -- condition FAKTOR <> 0
  -- driving condition signal I(0)
  I(0) <= I0(0);
  cond_I0: UNNAMED_cond_I0_circuit
    PORT MAP(
      reg_FAKTOR_out_0_7 => reg_FAKTOR_in(0 TO 7),
      OUTPUT => I0);
END struct;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY UNNAMED IS
  PORT(
    CLK, RESET : IN std_logic
  );
END UNNAMED;

ARCHITECTURE struct OF UNNAMED IS
  SIGNAL CLK_SIGNAL, RESET_SIGNAL : std_logic;
  SIGNAL C : std_logic_vector(0 to 5);
  SIGNAL I : std_logic_vector(0 to 0);

  COMPONENT UNNAMED_cu
    PORT (
      CLK, RESET : IN  std_logic;
      C          : OUT std_logic_vector(0 to 5);
      I          : IN  std_logic_vector(0 to 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_cu USE ENTITY WORK.UNNAMED_cu(struct);

  COMPONENT UNNAMED_ou
    PORT (
      CLK, RESET : IN  std_logic;
      C          : IN  std_logic_vector(0 to 5);
      I          : OUT std_logic_vector(0 to 0)
    );
  END COMPONENT;

  FOR ALL : UNNAMED_ou USE ENTITY WORK.UNNAMED_ou(struct);

BEGIN
  CLK_SIGNAL <= CLK;
  RESET_SIGNAL <= RESET;

  Control_Unit: UNNAMED_cu
    PORT MAP(
      CLK => CLK_SIGNAL,
      RESET => RESET_SIGNAL,
      C => C,
      I => I
    );

  Operation_Unit: UNNAMED_ou
    PORT MAP(
      CLK => CLK_SIGNAL,
      RESET => RESET_SIGNAL,
      C => C,
      I => I
    );
END struct;
